//-----------------------------------------------------------------------------
// utils.hh
//-----------------------------------------------------------------------------
//
// Collection of utility functions
//
//-----------------------------------------------------------------------------

#ifndef UTILS_H
#define UTILS_H

#include <math.h>
#include <vector>
using std::vector;

// x = [0:255] / 80.0;
// gtab = 1/sqrt(2*pi) * exp(-0.5 * x .^2);
const double gtab[] = {
    3.9894e-01, 3.9891e-01, 3.9882e-01, 3.9866e-01, 3.9844e-01, 3.9816e-01, 
    3.9782e-01, 3.9742e-01, 3.9695e-01, 3.9643e-01, 3.9584e-01, 3.9519e-01,
    3.9448e-01, 3.9371e-01, 3.9288e-01, 3.9199e-01, 3.9104e-01, 3.9004e-01,
    3.8897e-01, 3.8785e-01, 3.8667e-01, 3.8543e-01, 3.8414e-01, 3.8279e-01,
    3.8139e-01, 3.7993e-01, 3.7842e-01, 3.7686e-01, 3.7524e-01, 3.7357e-01,
    3.7186e-01, 3.7009e-01, 3.6827e-01, 3.6640e-01, 3.6449e-01, 3.6253e-01,
    3.6053e-01, 3.5848e-01, 3.5638e-01, 3.5424e-01, 3.5207e-01, 3.4984e-01,
    3.4758e-01, 3.4528e-01, 3.4294e-01, 3.4057e-01, 3.3815e-01, 3.3571e-01,
    3.3322e-01, 3.3071e-01, 3.2816e-01, 3.2558e-01, 3.2297e-01, 3.2033e-01,
    3.1767e-01, 3.1497e-01, 3.1225e-01, 3.0951e-01, 3.0674e-01, 3.0395e-01,
    3.0114e-01, 2.9830e-01, 2.9545e-01, 2.9258e-01, 2.8969e-01, 2.8679e-01,
    2.8387e-01, 2.8093e-01, 2.7798e-01, 2.7503e-01, 2.7205e-01, 2.6907e-01,
    2.6609e-01, 2.6309e-01, 2.6008e-01, 2.5707e-01, 2.5406e-01, 2.5104e-01,
    2.4802e-01, 2.4500e-01, 2.4197e-01, 2.3895e-01, 2.3592e-01, 2.3290e-01,
    2.2988e-01, 2.2687e-01, 2.2386e-01, 2.2085e-01, 2.1785e-01, 2.1486e-01,
    2.1188e-01, 2.0890e-01, 2.0594e-01, 2.0298e-01, 2.0004e-01, 1.9711e-01,
    1.9419e-01, 1.9128e-01, 1.8839e-01, 1.8551e-01, 1.8265e-01, 1.7980e-01,
    1.7697e-01, 1.7416e-01, 1.7137e-01, 1.6859e-01, 1.6584e-01, 1.6310e-01,
    1.6038e-01, 1.5769e-01, 1.5501e-01, 1.5236e-01, 1.4973e-01, 1.4712e-01,
    1.4453e-01, 1.4197e-01, 1.3943e-01, 1.3692e-01, 1.3442e-01, 1.3196e-01,
    1.2952e-01, 1.2710e-01, 1.2471e-01, 1.2235e-01, 1.2001e-01, 1.1770e-01,
    1.1541e-01, 1.1315e-01, 1.1092e-01, 1.0872e-01, 1.0654e-01, 1.0439e-01,
    1.0226e-01, 1.0017e-01, 9.8102e-02, 9.6062e-02, 9.4049e-02, 9.2064e-02,
    9.0108e-02, 8.8179e-02, 8.6277e-02, 8.4404e-02, 8.2558e-02, 8.0740e-02,
    7.8950e-02, 7.7188e-02, 7.5453e-02, 7.3745e-02, 7.2065e-02, 7.0412e-02,
    6.8786e-02, 6.7188e-02, 6.5616e-02, 6.4071e-02, 6.2552e-02, 6.1060e-02,
    5.9595e-02, 5.8155e-02, 5.6741e-02, 5.5353e-02, 5.3991e-02, 5.2654e-02,
    5.1342e-02, 5.0055e-02, 4.8792e-02, 4.7554e-02, 4.6340e-02, 4.5150e-02,
    4.3984e-02, 4.2841e-02, 4.1721e-02, 4.0624e-02, 3.9550e-02, 3.8498e-02,
    3.7469e-02, 3.6461e-02, 3.5475e-02, 3.4510e-02, 3.3566e-02, 3.2642e-02,
    3.1740e-02, 3.0857e-02, 2.9994e-02, 2.9151e-02, 2.8327e-02, 2.7522e-02,
    2.6736e-02, 2.5968e-02, 2.5218e-02, 2.4486e-02, 2.3772e-02, 2.3075e-02,
    2.2395e-02, 2.1731e-02, 2.1084e-02, 2.0453e-02, 1.9837e-02, 1.9238e-02,
    1.8653e-02, 1.8083e-02, 1.7528e-02, 1.6988e-02, 1.6461e-02, 1.5948e-02,
    1.5449e-02, 1.4963e-02, 1.4491e-02, 1.4031e-02, 1.3583e-02, 1.3148e-02,
    1.2724e-02, 1.2312e-02, 1.1912e-02, 1.1523e-02, 1.1145e-02, 1.0778e-02,
    1.0421e-02, 1.0074e-02, 9.7377e-03, 9.4109e-03, 9.0936e-03, 8.7856e-03,
    8.4867e-03, 8.1968e-03, 7.9155e-03, 7.6426e-03, 7.3780e-03, 7.1215e-03,
    6.8728e-03, 6.6317e-03, 6.3981e-03, 6.1718e-03, 5.9525e-03, 5.7402e-03,
    5.5345e-03, 5.3354e-03, 5.1426e-03, 4.9561e-03, 4.7755e-03, 4.6008e-03,
    4.4318e-03, 4.2684e-03, 4.1103e-03, 3.9575e-03, 3.8098e-03, 3.6670e-03,
    3.5290e-03, 3.3956e-03, 3.2668e-03, 3.1424e-03, 3.0223e-03, 2.9063e-03,
    2.7943e-03, 2.6862e-03, 2.5818e-03, 2.4812e-03
};

inline double max(double x, double y) { return (x > y) ? x : y; }
inline double min(double x, double y) { return (x < y) ? x : y; }

#define GD 0.39894228040143		// 1/sqrt(2*pi)
#define MIN_GAU 1.0e-6			// smoothed Gaussian

#ifdef FAST_GAUSS
inline double compute_g(double w, double m, double s) // Lookup table
{
    if (w > m)
	return (gtab[(int) min(255, 80*(w-m)/s)] / s);
    else
	return (gtab[(int) min(255, 80*(m-w)/s)] / s);
}
#else
inline double compute_g(double w, double m, double s)  
{
    double x = (w - m) / s;
    return max(GD * exp(-0.5 * x * x) / s, MIN_GAU);
}
#endif

// Approximate Psi(x), the cumunative of normal distribution N(0,1):
// Psi(x) = 1/sqrt(2*pi) * \int_{-infty}^x e^{-t^2/2}, x >= 0
inline double Psi(double x)
{
    double p = x * (1.5976 + 0.070566 * x * x);

    return (1.0 / (1.0 + exp(-p)));
}

int ipow(int n, int j);			// integer power
double ran1(int& idum);			// uniform random [0,1)
double rangas(int& idum);			// standard Gaussian
void ranprobs(vector<double>& vprobs, int& idum);// probs. add to one
int ranind(const vector<double>& vprobs, int& idum); // ret. random index

#endif //UTILS_H
